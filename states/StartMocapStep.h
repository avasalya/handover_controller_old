#pragma once

#include <iostream>
#include <fstream>

#include <mc_control/fsm/Controller.h>
#include <mc_control/fsm/State.h>

#include <mc_rbdyn/Robot.h>

#include "handover_controller.h"


#include "../cortex/cortex.h"


// Generated by cmake
#include "datapath.h"

namespace mc_handover
{
	namespace states
	{
		struct StartMocapStep : mc_control::fsm::State
		{
			EIGEN_MAKE_ALIGNED_OPERATOR_NEW

		public:
			void configure(const mc_rtc::Configuration & config) override;

			void start(mc_control::fsm::Controller&) override;

			bool run(mc_control::fsm::Controller&) override;

			void teardown(mc_control::fsm::Controller&) override;


			void plotPos(Eigen::MatrixXd m, int d);
			bool plotSize{true};


			/*mocap*/
			int body{0};
			std::vector<Eigen::Vector3d> Markers;
			std::vector<Eigen::MatrixXd> markersPos;


			int wristMarkerR{2};
			int fingerMarkerR{3};

			int markerObj{4};

			int knuckleMarkerS{5};
			int wristMarkerS{6};


			Eigen::Vector3d curPosLeftEf, curPosLeftEfMarker;
			Eigen::Vector3d initPosObjMarkerA, ithPosObjMarkerA, avgVelObjMarkerA, predictPos;

			Eigen::MatrixXd curVelObjMarkerA, wp;//, curPosObjMarkerA;
			Eigen::MatrixXd newPosObjMarkerA = Eigen::MatrixXd::Zero(3,t_observe);

			Eigen::Matrix3d curRotLeftEfMarker  = Eigen::Matrix3d::Identity();
			Eigen::Matrix3d rotObjMarkerA = Eigen::Matrix3d::Identity();
			Eigen::Matrix3d curRotLeftEf;

			std::tuple<Eigen::MatrixXd, Eigen::Vector3d, Eigen::Vector3d> wp_efL_objMarkerA;

			std::shared_ptr<mc_tasks::PositionTask> chestPosTask;
			std::shared_ptr<mc_tasks::OrientationTask> chestOriTask;

			sva::PTransformd ObjMarkerA_X_efL;

			sva::PTransformd ltHand;			

			double closeGrippers = 0.0;
			double openGrippers = 1.0;

			Eigen::Vector3d initRobotEfMarker;

			std::vector<std::string> activeJointsLeftArm =
			{
				"LARM_JOINT0",
				"LARM_JOINT1",
				"LARM_JOINT2",
				"LARM_JOINT3",
				"LARM_JOINT4",
				"LARM_JOINT5",
				"LARM_JOINT6",
				"LARM_JOINT7"
			};


			private:

				Eigen::VectorXd thresh = Eigen::VectorXd::Zero(12);
				std::vector<bool> handsWrenchDir;
				Eigen::Vector3d move, target;
				Eigen::Vector3d initialCom = Eigen::Vector3d::Zero();

				std::shared_ptr<mc_tasks::CoMTask> comTask;

				double pt;
				Eigen::MatrixXd pos;
				std::vector<double> pts;
				std::string name;


				int fps{200};

				int t_observe{20}; //100ms
				int t_predict{100};//1sec


				bool Flag_CORTEX{false}; // default True for MOCAP

				bool startCapture{false};

				bool collected{false};

				bool taskAdded{true};

				bool prediction{true}; // default true
				// bool stopPrediction{false};

				bool gripperOpenTrue{true};
				bool gripperCloseTrue{true};

				Eigen::Vector3d refPos, refVel, refAcc, initRefPos, gothere, initPos;

				sBodyDefs* pBodyDefs{NULL};
				sBodyDef* pBody{NULL};
				sFrameOfData* getCurFrame{NULL};
				sFrameOfData FrameofData;

				std::vector<int> bodyMarkers;

				void *pResponse;
				int nBytes;
				int retval = RC_Okay;
				int totalBodies;
				int i{1};
				

				double del{0};

			};


	} // namespace states
} // namespace mc_handover

EXPORT_SINGLE_STATE("StartMocapStep", mc_handover::states::StartMocapStep)